#! /bin/bash/

#export OCC=/home/marquez/hydrographr/spdata_1264942_ids_snap.csv
#export occ_key=occurrence_id
#export occ_lon=lon_snap
#export occ_lat=lat_snap
#
#export OBJ=/home/marquez/hydrographr/objects.csv
#export obj_key=occurrence_id
#export obj_lon=lon_snap
#export obj_lat=lat_snap
#
#export STREAM=/home/marquez/hydrographr/order_vect_59.gpkg
#export OUT=/home/marquez/hydrographr/dist_to_object.csv
#export TMP=/home/marquez/hydrographr
#export PAR=1

# ocurrence points
export OCC=$1    #  ocurrence points file (.csv)
export occ_key=$2   # name of ID column
export occ_lon=$3   # name of longitude coordinates column
export occ_lat=$4   # name of latitude coordinates column

# Object points (e.g. dams)
export OBJ=$5 
export obj_key=$6
export obj_lon=$7
export obj_lat=$8

# Stream vector file (.gpkg)
export STREAM=$9

# path to output file (.csv)
export OUT=${10}

# folder to store tmp data
export TMP=${11}

# number of cores if running in parallel (default can be set to 1)
export PAR=${12}


##  make the .csv files a gpkg
ogr2ogr -f "GPKG" -overwrite -nln occ_points -nlt POINT -a_srs EPSG:4326 \
    $TMP/occ_points.gpkg $OCC -oo X_POSSIBLE_NAMES=$occ_lon \
    -oo Y_POSSIBLE_NAMES=$occ_lat -oo AUTODETECT_TYPE=YES

ogr2ogr -f "GPKG" -overwrite -nln obj_points -nlt POINT -a_srs EPSG:4326 \
    $TMP/obj_points.gpkg $OBJ -oo X_POSSIBLE_NAMES=$obj_lon \
    -oo Y_POSSIBLE_NAMES=$obj_lat -oo AUTODETECT_TYPE=YES


grass78  -f -text --tmp-location  -c $STREAM   <<'EOF'

# read the cleaned stream network generated by r.stream.order
v.in.ogr --o -e input=$STREAM layer=SELECT output=stre_cl type=line key=stream

# occurrence points
v.in.ogr --o input=$TMP/occ_points.gpkg layer=occ_points output=occ type=point \
    key=$occ_key

# object points
v.in.ogr --o input=$TMP/obj_points.gpkg layer=obj_points output=obj type=point \
    key=$obj_key

# connect ocurrences to stream network
v.net --o input=stre_cl points=occ output=streams_occ operation=connect \
    thresh=1 arc_layer=1 node_layer=2


Dist2Obj(){

POINT=$1

# extract one point at a time
v.extract --o input=obj type=point cats=${POINT} output=sampleOne

# connect each object at a time in order to get distances from all points to
# each object (if all objects included simultaneously then only the shortest
# distance is calculated)
v.net --o input=streams_occ points=sampleOne output=streams_occ_obj \
    operation=connect thresh=1 arc_layer=1 node_layer=3

v.net.distance --o in=streams_occ_obj out=dist_occ_obj flayer=2 to_layer=3

v.report -c map=dist_occ_obj layer=1 option=length units=kilometers | \
    awk -F"|" '{printf "%s,%s,%.4f\n", $1, $2, $4}' \
    > $TMP/dist_occ_obj_${POINT}.csv

}

export -f Dist2Obj
export RANGE=($(v.db.select -c obj col=${obj_key}))
parallel -j $PAR --delay 5 Dist2Obj ::: ${RANGE[@]}

EOF

###  create header and join tmp tables
echo "${occ_key},${obj_key},distance" > $TMP/dist_to_Objects.csv
cat $( find $TMP/dist_occ_obj_*.csv ) >> $TMP/dist_to_Objects.csv

### reorder by Site ID
awk -F, 'NR == 1; NR > 1 {print $0 | "sort -n"}' $TMP/dist_to_Objects.csv \
    > $OUT

rm $TMP/dist_to_Objects.csv $TMP/dist_occ_obj_*.csv
rm $TMP/occ_points.gpkg $TMP/obj_points.gpkg

exit

###############################################################################
###############################################################################


